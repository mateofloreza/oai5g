From 71e1584ab1e09ecaf36e18fdda5cbf94ff3a5ae4 Mon Sep 17 00:00:00 2001
From: "thamizhselvan.k" <thamizhselvan.k@vvdntech.in>
Date: Wed, 17 Aug 2022 17:14:20 +0530
Subject: [PATCH 4/8] WA for timer handler not getting called after certain
 iteration

---
 fhi_lib/lib/src/xran_main.c | 21 ++++++++++++++-------
 1 file changed, 14 insertions(+), 7 deletions(-)

diff --git a/fhi_lib/lib/src/xran_main.c b/fhi_lib/lib/src/xran_main.c
index 8f5705e..3b187fc 100644
--- a/fhi_lib/lib/src/xran_main.c
+++ b/fhi_lib/lib/src/xran_main.c
@@ -780,7 +780,8 @@ void tti_ota_cb(struct rte_timer *tim, void *arg)
     }
 
     p_xran_dev_ctx->phy_tti_cb_done = 0;
-    xran_timer_arm_ex(&tti_to_phy_timer[xran_lib_ota_tti % 10], tti_to_phy_cb, (void*)pTCtx, tim_lcore);
+    //xran_timer_arm_ex(&tti_to_phy_timer[xran_lib_ota_tti % 10], tti_to_phy_cb, (void*)pTCtx, tim_lcore);
+    tti_to_phy_cb(&tti_to_phy_timer[xran_lib_ota_tti % 10],(void*)pTCtx);
 
     //slot index is increased to next slot at the beginning of current OTA slot
     xran_lib_ota_tti++;
@@ -795,11 +796,14 @@ void xran_timer_arm(struct rte_timer *tim, void* arg)
 {
     struct xran_device_ctx * p_xran_dev_ctx = xran_dev_get_ctx();
     uint64_t t3 = MLogTick();
+    void (*func)(void*,void *);
+    func = arg;
 
     if (xran_if_current_state == XRAN_RUNNING){
-        rte_timer_cb_t fct = (rte_timer_cb_t)arg;
-        rte_timer_init(tim);
-        rte_timer_reset_sync(tim, 0, SINGLE, p_xran_dev_ctx->fh_init.io_cfg.timing_core, fct, &timer_ctx[0]);
+        //rte_timer_cb_t fct = (rte_timer_cb_t)arg;
+        //rte_timer_init(tim);
+        //rte_timer_reset_sync(tim, 0, SINGLE, p_xran_dev_ctx->fh_init.io_cfg.timing_core, fct, &timer_ctx[0]);
+        func(NULL,&timer_ctx[0]);
     }
     MLogTask(PID_TIME_ARM_TIMER, t3, MLogTick());
 }
@@ -811,6 +815,8 @@ void xran_timer_arm_for_deadline(struct rte_timer *tim, void* arg)
     static int timer_cnt = 0;
     unsigned tim_lcore =  (p_xran_dev_ctx->fh_init.io_cfg.pkt_proc_core) ? p_xran_dev_ctx->pkt_proc_core_id :
                                                                            p_xran_dev_ctx->fh_init.io_cfg.timing_core;
+    void (*func)(void*,void *);
+    func = arg;
 
     int32_t rx_tti;
     int32_t cc_id;
@@ -828,9 +834,10 @@ void xran_timer_arm_for_deadline(struct rte_timer *tim, void* arg)
     cb_timer_ctx[timer_cnt].tti_to_process = rx_tti;
 
     if (xran_if_current_state == XRAN_RUNNING){
-        rte_timer_cb_t fct = (rte_timer_cb_t)arg;
-        rte_timer_init(tim);
-        rte_timer_reset_sync(tim, 0, SINGLE, tim_lcore, fct, &cb_timer_ctx[timer_cnt++]);
+        //rte_timer_cb_t fct = (rte_timer_cb_t)arg;
+        //rte_timer_init(tim);
+        //rte_timer_reset_sync(tim, 0, SINGLE, tim_lcore, fct, &cb_timer_ctx[timer_cnt++]);
+        func(NULL,&cb_timer_ctx[timer_cnt++]);
         if (timer_cnt >= 10*MAX_NUM_OF_XRAN_CTX)
             timer_cnt = 0;
     }
-- 
2.25.1

